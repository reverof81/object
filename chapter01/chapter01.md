# 객체, 설계

- Robert L. Glass: 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다.

## 티켓 판매 애플리케이션 구현하기

<img src="img/1.1.png" alt="애플리케이션 핵심 클래스" width="1200" />

## 무엇이 문제인가

- Robert C. Martin 의 소프트웨어 모듈이 가져야 하는 세가지 기능
    - 제대로 실행 돼야 한다.
    - 변경이 용이해야 한다.
    - 이해하기 쉬워야 한다.

### 예상을 빗나가는 코드

#### 현재 구현 코드는

1. 소극장은 관람객의 가방을 열어 그 안에 초대장이 들어있는지 살펴본다.
2. 가방안에 초대장이 들어있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.
3. 가방 안에 초대장이 들어있지 않다면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한 후 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.

#### 현실에서는

1. 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건낸다.
2. 티켓을 구매하는 관람객은 가방 안에서 돈을 직접 꺼내 판매원에게 지불한다.
3. 판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고 관람객에게서 직접 돈을 받아 매표소에 보관한다.

#### 문제점

- 하나의 클래스나 메서드에서 너무 많은 세부사항을 다룬다.
- `Audience` 와 `TicketSeller` 를 변경할 경우 `Theater` 도 변경해야 한다.

### 변경에 취약한 코드

- 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다닌다고 가정한다.
- 판매원이 매표소에서만 티켓을 판매한다고 가정한다.
- 이런 가정들이 깨지는 순간 모든 코드가 일시에 흔들리게 된다.

<img src="img/1.2.png" alt="너무 많은 클래스에 의존하는 Theater" width="1200" />

#### 목표

- 애플리케이션 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거한다.
- 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만든다.

## 설계 개선하기

- `Theater` 가 `Audience` 와 `TicketSeller` 에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단.
- 관람객과 판매원을 자율적인 존재로 만들기.

### 자율성을 높이자

1. `Theater` 의 `enter` 메서드에서 `TicketOffice` 에 접근하는 모든 코드를 `TicketSeller` 내부로 숨김

<img src="img/1.4.png" alt="Theater 의 결합도를 낮춘 설계" width="1200" />

2. `TicketSeller` 에서 `Audience` 의 `Bag` 에 접근하던 코드를 `Audience` 캡슐화를 통해 개선

<img src="img/1.6.png" alt="자율적인 Audience 와 TicketSeller 로 구성된 설계" width="1200" />

### 무엇이 개선됐는가

- 코드를 읽는 사람과의 의사소통의 관점에서 개선됨
- 변경 용이성 측면에서도 개선됨

### 어떻게 한 것인가

- 수정한 후의 `Theater` 는 `Audience` 나 `TicketSeller` 내부에 직접 접근하지 않는다.

### 캡슐화와 응집도

- 핵심은 객체 내부의 상태를 캡슐화 하고 객체 간에 오직 메세지를 통해서만 상호 작용 하도록 만드는 것

1. **캡슐화(encapsulation)**
    1. 변경하기 쉬운 객체를 만든다.
    2. 객체간 결합도를 낮춘다.
2. **응집도(cohesion)**
    1. 연관성 없는 작업은 다른 객체에 위임한다.
    2. 객체 스스로 자신의 데이터를 책임진다.

### 절차 지향과 객체 지향

1. **절차적 프로그래밍(Procedural Programming)**
    - 그림 1.2
    - 프로세스(process) 와 데이터(data) 를 별도의 모듈에 위치시키는 방식
    - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다.
2. **객체지향 프로그래밍(Object-Oriented Programming)**
    - 그림 1.6
    - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식
    - 캡슐화를 이용해 의존성을 관리함으로써 객체 사이의 결합도를 낮춤

### 책임의 이동(shift of responsibility)

- 절차적 프로그래밍 방식으로 작성된 처리 흐름 -> 주로 `Theater` 에 의해 제어된다.

<img src="img/1.7.png" alt="책임이 중앙 집중된 절차적 프로그래밍" width="1200" />

- 객체지향 설계 -> 제어 흐름이 각 객체에 적절하게 분산돼 있다.

<img src="img/1.8.png" alt="책임이 분산된 객체지향 프로그래밍" width="1200" />

- `Theater` 에 몰려있던 책임이 개별 객체로 이동했다.
- 적절한 객체에 적절한 책임을 할당하면 이해하기 쉬운 구조화 읽기 쉬운 코드를 얻게 된다.

### 더 개선할 수 있다

- `TicketSeller` 의 `sellTo` 구현을 `TicketOffice` 로 이동시켰을 경우 그림 1.9 와 같은 `TicketOffice` 의 `Audience` 에 대한 의존성이 생겨 버린다.

<img src="img/1.9.png" alt="TicketOffice 에서 Audience 로 향하는 의존성이 추가된다" width="1200" />

- 설계는 트레이드오프의 산물이다. 어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들 수는 없다.
- 설계는 균형의 예술이다. 훌륭한 설계는 적절한 트레이드오프의 결과물이다.

### 그래, 거짓말이다!

- **의인화(anthropomorphism)**
    - 객체지향의 세계에서 모든것을 능동적이고 자율적인 존재로 바꿔 설계하는 원칙 (Rebecca Wirfs-Brock)
    - 객체들은 능동적이고 자율적인 에이전트 이다.
    - 실 세계에서는 생명이 없는 수동적인 존재일지라도 객체지향의 세계에서는 생명과 지능을 가진 존재이다.

## 객체지향 설계

### 설계가 왜 필요한가

- 설계란 코드를 배치하는것이다.
- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 수용할 수 있는 설계다.
- 변경을 수용할 수 있는 설계가 중요한 이유
    - 요구사항이 항상 변경되기 때문
    - 코드를 변경할 때 버그가 추가될 가능성이 높기 때문

### 객체지향 설계

- 변경에 유연하게 대응할 수 있는 코드
- 이해하기 쉬운 코드
- 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계
